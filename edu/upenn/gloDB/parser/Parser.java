/* Generated By:JavaCC: Do not edit this line. Parser.java */
        package edu.upenn.gloDB.parser;
        import edu.upenn.gloDB.*;
        import java.io.StringReader;
        import java.util.HashMap;
        import java.util.HashSet;
        import java.util.ArrayList;
        import java.util.Iterator;


        /**
	 * The parser is created using javacc.  To make changes to the parser,
	 * the files Parser.jj, Operation.java, Operator.java, and
	 * ParserUtils.java are the only files that should be edited.  All
	 * other files are recreated by javacc from Parser.jj.
	 * After Parser.jj is edited, makeParser.bat should be run.  This will 
	 * update the relevant parser java files.  After makeParser is run, then
	 * this file should be run to add the parser changes into gloDB.jar.
	 *
	 */
        public class Parser implements ParserConstants {
                /** The String to be parsed. */
//		public String parse = "";

                /** An ArrayList containing the parsed Tracks. */
                private ArrayList parsed = new ArrayList();

                /** The set of Tracks to be used. */
                private HashMap trackPool;

                /** The set of Sequences to be used. */
                private HashMap sequencePool;

                /** 
		 * The ID of the new Track object.
		 */
                private String id;

                /** 
		 * The list of Operations defined by 'parse'.
		 */
//		public ArrayList ops = new ArrayList();

                /**
		 * Construct a new Parser using trackPool
		 * as the set Tracks to search.
		 */
                public Parser(String parse) throws ParseException {
                        this(new StringReader(parse));
                }

                //--------------------------------------------------------------------------
                // Getters and Setters

                public String getId() { return id; }

                //--------------------------------------------------------------------------
                // Miscellaneous Methods

                /** 
		 * Performs the parsing.  Returns the ops ArrayList
		 * which is a list of operations to perform.  The first object
		 * in the ArrayList is the ID of the new Track.
		 */
                public ArrayList run(HashMap trackPool, HashMap sequencePool) throws ParseException {
                        this.trackPool = trackPool;
                        this.sequencePool = sequencePool;
                        ArrayList ops = parseLine();

                        // if the next token is a valid token (ie an object or track) then the 
                        // parser will finish but not complain, ignoring the valid token.
                        // Here we test to see if there is any valid token following the last
                        // token parsed and if so then we know there was an error.
                        // For example, the parser won't complain about "t = t1 t2",
                        // but will stop parsing after "t1" and finish without an
                        // error.  Since this is an invalid computation, we check for
                        // it here and throw an error.  In this example, 'token'
                        // will represent "t1" and 'token.next' will contain the token "t2".
                        if (token.next.kind != 0) {
                                Token tn = token.next;
                                String msg = "Lexical error at line " + tn.beginLine + ", column " + tn.beginColumn + ".";
                                msg += "  Encountered: \"" + tn.image + "\".";
                                throw new ParseException(msg);
                        }

//			GloDBUtils.printMsg("Parse table: " + ops);

                        // if there is an Edge without any Features, then return 'null'
                        // because "ops" can not be matched.
                        // XXX this currently only tests the top level 'group'
                        if (! validOperation(ops)) {
                                String out = "This expression has at least one empty element.\n";
                                out += "Make sure that the qualifiers (ie sequence\n";
                                out += "specifications, width, etc) are valid.";
                                GloDBUtils.printWarning(out);
//				return null;
                        }

                        return ops;
                }

                /**
		 * Test if 'ops' contains any Operations that lack a Feature.
		 */
                private boolean validOperation(ArrayList ops) {
                        boolean valid = true;  // flag if valid operation
                        Iterator i = ops.iterator();
                        while (i.hasNext() && valid) {
                                Operation operation = (Operation) i.next();
                                if (operation.track == null) {
                                        // Recursively test any groups
                                        valid = validOperation(operation.getGroup());
                                } else if (operation.track.numFeatures() == 0) {
                                        valid = false;
                                }
                        }
                        return valid;
                }

                /** 
		 * Returns the string to be parsed and the same string 
		 * having been parsed information. 
		 */
                public String toString() {
                        String out = "";

//			out += "Parser operation table: " + ops + "\n";
                        out += "Parser operation table: " + parsed + "\n";

                        return out;
                }


                //--------------------------------------------------------------------------
                // Parsing Related Methods

                /** Deal with length/from values. */
                private void addLength(int a, int b, int c, int d) {
                        if (a == -1) {  // has 'from', no 'length'.
                                parsed.add("from");
                                if (d > -1) { parsed.add(Integer.toString(c) + ", " + Integer.toString(d)); }
                                else { parsed.add(Integer.toString(c)); }

                        } else {  // has 'length'
                                parsed.add("len");
                                if (b > -1) { parsed.add(Integer.toString(a) + ", " + Integer.toString(b)); }
                                else { parsed.add(Integer.toString(a)); }

                                if (c > -1) {  // has 'from'
                                        parsed.add("from");
                                        if (d > -1) { parsed.add(Integer.toString(c) + ", " + Integer.toString(d)); }
                                        else { parsed.add(Integer.toString(c)); }
                                }
                        }
                }

                /** Deal with repeat/within values. */
                private void addRepeat(int a, int b, int c, int d) {
                        parsed.add("repeated");
                        if (b > -1) { parsed.add(Integer.toString(a) + ", " + Integer.toString(b)); }
                        else { parsed.add(Integer.toString(a)); }

                        if (c > -1) { // test for 'within'
                                parsed.add("within");
                                if (d > -1) { parsed.add(Integer.toString(c) + ", " + Integer.toString(d)); }
                                else { parsed.add(Integer.toString(c)); }
                        }
                }

                /** Chop off preceeding descriptor. */
                private String stripDescriptor(String a) {
                        if (a.startsWith(" followed by")) { a = a.substring(12); }
                        if (a.startsWith(" then")) { a = a.substring(5); }
                        return a;
                }

                public String formatParsed() {
                        if (parsed.isEmpty()) { return ""; }

                        Iterator i = parsed.iterator();
                        String out = (String) i.next();

                        while (i.hasNext()) {
                                String track = (String) i.next();
                                out += " " + track;
                        }

                        return out;
                }

  final public ArrayList parseLine() throws ParseException {
        String assign;
        ArrayList ops = new ArrayList();
    assign = trackAssign();
                                                  this.id = assign;
    expr(ops);
                                  {if (true) return ops;}
    throw new Error("Missing return statement in function");
  }

  final public String trackAssign() throws ParseException {
        Token t;
    t = jj_consume_token(ASSIGN);
                                String id = (t.toString()).trim();
                                // return id without the "="
                                {if (true) return (id.substring(0, id.length()-1)).trim();}
    throw new Error("Missing return statement in function");
  }

  final public void expr(ArrayList ops) throws ParseException {
        Operation operation;
    operation = track(-1);
                                                  ops.add(operation);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POS:
      case AND:
      case sAND:
      case OR:
      case MINUS:
      case sMINUS:
      case bAND:
      case bOR:
      case bMINUS:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      operation = opExpr();
                                                  ops.add(operation);
    }
  }

  final public Operation opExpr() throws ParseException {
        int a = 0;
        int b = Integer.MIN_VALUE;
        int flag = -1;
        int type;
        int minPos = 0;  // default to 0 space
        int maxPos = 0;  // default to 0 space

        Operation operation = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AND:
    case sAND:
    case OR:
    case MINUS:
    case sMINUS:
    case bAND:
    case bOR:
    case bMINUS:
      type = operator();
      break;
    case POS:
      type = position();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lREPEAT:
      case HOOK:
      case PLUS:
      case STAR:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case lREPEAT:
          jj_consume_token(lREPEAT);
          a = nValue();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEPARATOR:
            jj_consume_token(SEPARATOR);
            b = nValue();
            break;
          default:
            jj_la1[1] = jj_gen;
            ;
          }
          jj_consume_token(rREPEAT);
          break;
        case HOOK:
        case PLUS:
        case STAR:
          flag = oRepeat();
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    operation = track(type);
                                // if POS or '.', then compute minPos and maxPos
                                if ((type == 0) || (type == 10)) {
                                        if (flag == 0) {                        // <HOOK>
                                                minPos = 0;
                                                maxPos = 1;
                                        } else if (flag == 1) { // <PLUS>
                                                minPos = 1;
                                                maxPos = -1;
                                        } else if (flag == 2) { // <STAR>
                                                minPos = 0;
                                                maxPos = -1;
                                        } else {
                                                minPos = a;
                                                // make sure max => min
                                                if (b < a) { maxPos = a; }
                                                else { maxPos = b; }
                                        }
                                }

                                // update OPERATOR (type) info for the current Operation
                                operation.setType(type);

                                // add positional info
                                operation.minPos = minPos;
                                operation.maxPos = maxPos;

                                {if (true) return operation;}
    throw new Error("Missing return statement in function");
  }

  final public Operation track(int type) throws ParseException {
        boolean ignore = false;
        boolean negate = false;
        Operation operation;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IGNORE:
      ignore();
                                          ignore = true;
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case bNOT:
      negate();
                              negate = true;
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case lGROUP:
      operation = group();
      break;
    case allTRACKS:
    case OBJECT:
    case TRACK:
      operation = feature();
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                if (ignore) { operation.setIgnore(ignore); }            // set ignore flag
                                if (negate) { operation.setNegate(negate); }    // set negate flag

    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lLENGTH:
      case lLENGTH2:
      case LENGTH:
      case FROM:
      case lREPEAT:
      case HOOK:
      case PLUS:
      case STAR:
      case REPEATED:
      case SEQUENCE:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lREPEAT:
      case REPEATED:
        operation = densityRepeat(operation);

        break;
      case HOOK:
      case PLUS:
      case STAR:
        operation = operatorRepeat(operation);
                                if ((type != 0) && (type != 10)) {
                                        GloDBUtils.printWarning("Repeat is invalid following a \"" + Operator.getType(type) + "\" operator and will be ignored.");
                                }
        break;
      case lLENGTH:
      case lLENGTH2:
      case LENGTH:
      case FROM:
        operation = length(operation);
        break;
      case SEQUENCE:
        operation = sequence(operation);
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                          {if (true) return operation;}
    throw new Error("Missing return statement in function");
  }

  final public Operation group() throws ParseException {
        ArrayList ops = new ArrayList();
    jj_consume_token(lGROUP);
                                                  parsed.add("(");
    expr(ops);
    jj_consume_token(rGROUP);
                                                  parsed.add(")");
                          {if (true) return new Operation(ops);}
    throw new Error("Missing return statement in function");
  }

/*
Operation setTracks():
{
	Operation operation;
	HashSet tracks = new HashSet();
	Track track;
}
{
	<lSET>					{ parsed.add("["); }
	(
		track=trackRef()	{ tracks.add(track); }
	)*
	<rSET>					{ parsed.add("]"); }
			{ return new Operation(tracks); }
}
*/
  final public Operation feature() throws ParseException {
        Operation operation;
        Track track;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case allTRACKS:
      allTracks();
                                HashSet tracks = new HashSet();
                                for (Iterator i = trackPool.keySet().iterator(); i.hasNext();) {
                                        String key = (String) i.next();
                                        tracks.add(trackPool.get(key));
                                }
                                operation = new Operation(tracks);
      break;
    case OBJECT:
    case TRACK:
      track = trackRef();
                          operation = new Operation(track);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                          {if (true) return operation;}
    throw new Error("Missing return statement in function");
  }

  final public Operation densityRepeat(Operation operation) throws ParseException {
        int a = -1;
        int b = -1;
        int c = -1;
        int d = -1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case lREPEAT:
      jj_consume_token(lREPEAT);
      a = value();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEPARATOR:
        jj_consume_token(SEPARATOR);
        b = value();
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 47:
        jj_consume_token(47);
        c = value();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEPARATOR:
          jj_consume_token(SEPARATOR);
          d = value();
          break;
        default:
          jj_la1[12] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
      jj_consume_token(rREPEAT);
      break;
    case REPEATED:
      jj_consume_token(REPEATED);
      a = value();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEPARATOR:
        jj_consume_token(SEPARATOR);
        b = value();
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TIMES:
        jj_consume_token(TIMES);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WITHIN:
        jj_consume_token(WITHIN);
        c = value();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEPARATOR:
          jj_consume_token(SEPARATOR);
          d = value();
          break;
        default:
          jj_la1[16] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case POSITIONS:
          jj_consume_token(POSITIONS);
          break;
        default:
          jj_la1[17] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                // add items to 'parsed'
                                addRepeat(a, b, c, d);

                                // add repeat info.  Only add info that was actually set.
                                if (b == -1) {
                                        // if 'b' not set but 'a' is, then set 'b' equal to 'a'
                                        b = a;
                                }
                                if (c > -1) {
                                        if (d == -1) {
                                                // if 'd' not set but 'c' is, then set 'd' equal to 'c'
                                                operation.setRepeat(a, b, c, c);
                                        } else {
                                                operation.setRepeat(a, b, c, d);
                                        }
                                } else {
                                        operation.setRepeat(a, b);
                                }

                                {if (true) return operation;}
    throw new Error("Missing return statement in function");
  }

  final public Operation operatorRepeat(Operation operation) throws ParseException {
        int flag = -1;
        int minRepeat;
        int maxRepeat;
    flag = oRepeat();
                                if (flag == 0) {                        // <HOOK>
                                        minRepeat = 0;
                                        maxRepeat = 1;
                                } else if (flag == 1) { // <PLUS>
                                        minRepeat = 1;
                                        maxRepeat = -1;
                                } else {                                                // <STAR>
                                        minRepeat = 0;
                                        maxRepeat = -1;
                                }

                                // add repeat info
                                operation.setRepeat(minRepeat, maxRepeat);

                                {if (true) return operation;}
    throw new Error("Missing return statement in function");
  }

  final public Operation length(Operation operation) throws ParseException {
        int a = -1;
        int b = -1;
        int c = -1;
        int d = -1;
    if (jj_2_1(3)) {
      jj_consume_token(lLENGTH2);
      c = value();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEPARATOR:
        jj_consume_token(SEPARATOR);
        d = value();
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      jj_consume_token(rLENGTH);
                          addLength(a, b, c, d);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lLENGTH:
        jj_consume_token(lLENGTH);
        a = value();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEPARATOR:
          jj_consume_token(SEPARATOR);
          b = value();
          break;
        default:
          jj_la1[21] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 47:
          jj_consume_token(47);
          c = value();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEPARATOR:
            jj_consume_token(SEPARATOR);
            d = value();
            break;
          default:
            jj_la1[22] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[23] = jj_gen;
          ;
        }
        jj_consume_token(rLENGTH);
                          addLength(a, b, c, d);
        break;
      case LENGTH:
        jj_consume_token(LENGTH);
        a = value();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEPARATOR:
          jj_consume_token(SEPARATOR);
          b = value();
          break;
        default:
          jj_la1[24] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FROM:
          jj_consume_token(FROM);
          c = value();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEPARATOR:
            jj_consume_token(SEPARATOR);
            d = value();
            break;
          default:
            jj_la1[25] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[26] = jj_gen;
          ;
        }
                          addLength(a, b, c, d);
        break;
      case FROM:
        jj_consume_token(FROM);
        c = value();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEPARATOR:
          jj_consume_token(SEPARATOR);
          d = value();
          break;
        default:
          jj_la1[27] = jj_gen;
          ;
        }
                          addLength(a, b, c, d);
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                                // setLength() and setSeqPos() will propogate to inner groups
                                if (a > -1) {
                                        if (b > -1) { operation.setLength(a, b); }
                                        else { operation.setLength(a, a); }
                                }
                                if (c > -1) {
                                        // if no 'd' then flag that max is sequence length
                                        if (d > -1) { operation.setSeqPos(c, d); }
                                        else { operation.setSeqPos(c, -1); }
                                }
                                {if (true) return operation;}
    throw new Error("Missing return statement in function");
  }

  final public Operation sequence(Operation operation) throws ParseException {
        Sequence seq;
    seq = sequenceRef();
                                // add Sequence info to the Operation.  This will propogate to
                                // all inner groups.
                                operation.setSequence(seq);

                                {if (true) return operation;}
    throw new Error("Missing return statement in function");
  }

  final public void allTracks() throws ParseException {
        Token t;
    t = jj_consume_token(allTRACKS);
                                                  parsed.add("T");
  }

  final public Track trackRef() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRACK:
      jj_consume_token(TRACK);
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    t = jj_consume_token(OBJECT);
                                String a = t.toString();
//				if (a.startsWith("feature")) { a = a.substring(4);	}
                                if (a.startsWith("a feature in")) { a = a.substring(14);        }
                                if (a.startsWith("track")) { a = a.substring(8);        }

                                parsed.add(a);
                                if (a.startsWith("T:") || a.startsWith("t:")) {
                                        a = a.substring(2);   // chop off the "T:"
                                }
                                a = a.trim();

                                Track track = (Track) trackPool.get(a);

                                if (track == null) {
                                        String msg = "Track \"" + a + "\" not found.";
//					GloDBUtils.printError(msg);
                                        {if (true) throw new ParseException(msg);}
                                }

                                {if (true) return track;}
    throw new Error("Missing return statement in function");
  }

  final public int position() throws ParseException {
        Token t;
        int flag;
    t = jj_consume_token(POS);
                                          flag = 0;
                                parsed.add(t.toString());
                                {if (true) return flag;}
    throw new Error("Missing return statement in function");
  }

  final public Sequence sequenceRef() throws ParseException {
        Token t;
        String a;
    jj_consume_token(SEQUENCE);
    t = jj_consume_token(OBJECT);
                                a = t.toString();
                                if (a.startsWith("seq")) { a = a.substring(4); }
                                if (a.startsWith("on sequence")) { a = a.substring(12); }

                                parsed.add(a);
                                if (a.startsWith("S:") || a.startsWith("s:")) {
                                        a = a.substring(2);   // chop off the "S:"
                                }
                                a = a.trim();

                                Sequence s = (Sequence) sequencePool.get(a);
                                if (s == null) {
                                        String msg = "Sequence \"" + a + "\" not found.";
//					GloDBUtils.printError(msg);
                                        {if (true) throw new ParseException(msg);}
                                }

                                {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public void ignore() throws ParseException {
        Token t;
    t = jj_consume_token(IGNORE);
                                          parsed.add(t.toString());
  }

  final public void negate() throws ParseException {
        Token t;
    t = jj_consume_token(bNOT);
                                                  parsed.add(t.toString());
  }

  final public int operator() throws ParseException {
        Token t;
        int flag;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AND:
      t = jj_consume_token(AND);
                                          flag = 1;
      break;
    case OR:
      t = jj_consume_token(OR);
                                          flag = 2;
      break;
    case MINUS:
      t = jj_consume_token(MINUS);
                                          flag = 3;
      break;
    case sAND:
      t = jj_consume_token(sAND);
                                                  flag = 4;
      break;
    case sMINUS:
      t = jj_consume_token(sMINUS);
                                          flag = 5;
      break;
    case bAND:
      t = jj_consume_token(bAND);
                                                  flag = 11;
      break;
    case bOR:
      t = jj_consume_token(bOR);
                                          flag = 12;
      break;
    case bMINUS:
      t = jj_consume_token(bMINUS);
                                          flag = 13;
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                parsed.add(t.toString());
                                {if (true) return flag;}
    throw new Error("Missing return statement in function");
  }

  final public int oRepeat() throws ParseException {
        Token t;
        int flag;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HOOK:
      t = jj_consume_token(HOOK);
                                                  flag = 0;
      break;
    case PLUS:
      t = jj_consume_token(PLUS);
                                                  flag = 1;
      break;
    case STAR:
      t = jj_consume_token(STAR);
                                                  flag = 2;
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                parsed.add(t.toString());
                                {if (true) return flag;}
    throw new Error("Missing return statement in function");
  }

  final public int value() throws ParseException {
        Token t;
    t = jj_consume_token(INTEGER);
                                          {if (true) return Integer.parseInt(t.toString());}
    throw new Error("Missing return statement in function");
  }

  final public int nValue() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      t = jj_consume_token(INTEGER);
                                                  {if (true) return Integer.parseInt(t.toString());}
      break;
    case nINTEGER:
      t = jj_consume_token(nINTEGER);
                                          {if (true) return Integer.parseInt(t.toString());}
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_3R_4() {
    if (jj_scan_token(SEPARATOR)) return true;
    return false;
  }

  final private boolean jj_3R_3() {
    if (jj_scan_token(INTEGER)) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_scan_token(lLENGTH2)) return true;
    if (jj_3R_3()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_4()) jj_scanpos = xsp;
    if (jj_scan_token(rLENGTH)) return true;
    return false;
  }

  public ParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[33];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0xff000000,0x200,0x20000,0x20000,0xff000000,0x800000,0x0,0x80000,0x3b000,0x3b000,0x0,0x200,0x200,0x0,0x200,0x0,0x200,0x0,0x0,0x20000,0x200,0x200,0x200,0x0,0x200,0x200,0x10000,0x200,0x19000,0x0,0xfe000000,0x0,0xc00,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x1,0x0,0x1c,0x1c,0x1,0x0,0x2,0x2c00,0x411c,0x411c,0x2c00,0x0,0x0,0x8000,0x0,0x80,0x0,0x200,0x40,0x100,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x2000,0x1,0x1c,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[1];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public Parser(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public Parser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[48];
    for (int i = 0; i < 48; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 33; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 48; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 1; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

        }
